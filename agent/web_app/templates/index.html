<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EntropyAware Answer Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: #212121;
            color: #e1e1e1;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 260px;
            background: #171717;
            border-right: 1px solid #2d2d2d;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid #2d2d2d;
        }

        .new-thread-btn {
            width: 100%;
            background: transparent;
            color: #e1e1e1;
            border: 1px solid #4d4d4d;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .new-thread-btn:hover {
            background: #2d2d2d;
            border-color: #666;
        }

        .threads-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .thread-item {
            width: 100%;
            display: block;
            text-align: left;
            padding: 12px 16px;
            margin-bottom: 4px;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            color: #e1e1e1;
            font-size: 14px;
            position: relative;
        }

        .thread-item:hover {
            background: #2d2d2d;
        }

        .thread-item:hover .delete-thread-btn {
            opacity: 1;
        }

        .thread-item.active {
            background: #2d2d2d;
        }

        .thread-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #10a37f;
            border-radius: 0 2px 2px 0;
        }

        .thread-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .thread-title {
            font-weight: 400;
            color: #e1e1e1;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .thread-meta {
            font-size: 12px;
            color: #8e8ea0;
        }

        .delete-thread-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: #2d2d2d;
            border: 1px solid #4d4d4d;
            color: #8e8ea0;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            opacity: 0;
            transition: all 0.2s;
            z-index: 10;
        }

        .delete-thread-btn:hover {
            background: #ff4444;
            border-color: #ff4444;
            color: white;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #212121;
            position: relative;
        }

        .mobile-header {
            display: none;
            padding: 16px;
            background: #171717;
            border-bottom: 1px solid #2d2d2d;
            align-items: center;
            gap: 12px;
        }

        .menu-toggle {
            background: none;
            border: none;
            color: #e1e1e1;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
        }

        .chat-header {
            padding: 16px 24px;
            border-bottom: 1px solid #2d2d2d;
            background: #212121;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .chat-header h1 {
            color: #e1e1e1;
            font-size: 18px;
            font-weight: 600;
        }

        .current-thread {
            font-size: 12px;
            color: #8e8ea0;
            margin-top: 4px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        .message-wrapper {
            width: 100%;
            padding: 24px;
            border-bottom: 1px solid #2d2d2d;
        }

        .message-wrapper.user {
            background: #212121;
        }

        .message-wrapper.assistant {
            background: #171717;
        }

        .message-content {
            max-width: 768px;
            margin: 0 auto;
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .message-avatar.user {
            background: #10a37f;
            color: white;
        }

        .message-avatar.assistant {
            background: #4d4d4d;
            color: #e1e1e1;
        }

        .message-text {
            flex: 1;
            line-height: 1.6;
            font-size: 15px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .message-text.streaming::after {
            content: '‚ñã';
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .chat-input-container {
            padding: 16px 24px 24px;
            background: #212121;
            border-top: 1px solid #2d2d2d;
        }

        .chat-input-wrapper {
            max-width: 768px;
            margin: 0 auto;
            position: relative;
        }

        .chat-input-form {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            background: #2d2d2d;
            border: 1px solid #4d4d4d;
            border-radius: 12px;
            padding: 12px 16px;
            color: #e1e1e1;
            font-size: 15px;
            resize: none;
            min-height: 20px;
            max-height: 200px;
            font-family: inherit;
            overflow-y: hidden;
            overflow-x: hidden;
        }

        .chat-input:focus {
            outline: none;
            border-color: #10a37f;
        }

        .chat-input::placeholder {
            color: #8e8ea0;
        }

        /* Chat input scrollbar styling */
        .chat-input::-webkit-scrollbar {
            width: 6px;
        }

        .chat-input::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-input::-webkit-scrollbar-thumb {
            background: #4d4d4d;
            border-radius: 3px;
        }

        .chat-input::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        .send-btn {
            background: #10a37f;
            border: none;
            border-radius: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
            color: white;
            font-size: 16px;
        }

        .send-btn:hover:not(:disabled) {
            background: #0d8f6b;
        }

        .send-btn:disabled {
            background: #4d4d4d;
            cursor: not-allowed;
            color: #8e8ea0;
        }

        .error {
            background: #2d1b1b;
            color: #ff6b6b;
            padding: 16px;
            border-radius: 8px;
            margin: 16px 24px;
            border: 1px solid #4d2d2d;
            font-size: 14px;
        }

        .welcome-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #8e8ea0;
            max-width: 600px;
            padding: 0 24px;
        }

        .welcome-message h2 {
            color: #e1e1e1;
            margin-bottom: 16px;
            font-weight: 600;
            font-size: 32px;
        }

        .welcome-message p {
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 32px;
        }

        .welcome-suggestions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 12px;
            margin-top: 24px;
        }

        .suggestion-card {
            background: #2d2d2d;
            border: 1px solid #4d4d4d;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .suggestion-card:hover {
            background: #3d3d3d;
            border-color: #666;
        }

        .suggestion-title {
            font-weight: 500;
            color: #e1e1e1;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .suggestion-desc {
            font-size: 12px;
            color: #8e8ea0;
            line-height: 1.4;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100vh;
                z-index: 1000;
                transform: translateX(-100%);
            }

            .sidebar.show {
                transform: translateX(0);
            }

            .mobile-header {
                display: flex;
            }

            .chat-header {
                display: none;
            }

            .chat-input-container {
                padding: 12px 16px 16px;
            }

            .welcome-message {
                padding: 0 16px;
            }

            .welcome-message h2 {
                font-size: 28px;
            }

            .welcome-suggestions {
                grid-template-columns: 1fr;
            }
        }

        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        .sidebar-overlay.show {
            display: block;
        }

        /* Scrollbar styling */
        .threads-list::-webkit-scrollbar,
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .threads-list::-webkit-scrollbar-track,
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .threads-list::-webkit-scrollbar-thumb,
        .chat-messages::-webkit-scrollbar-thumb {
            background: #4d4d4d;
            border-radius: 3px;
        }

        .threads-list::-webkit-scrollbar-thumb:hover,
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Confidence meter styles */
        .confidence-meter {
            position: fixed;
            top: 16px;
            right: 16px;
            background: #171717;
            border: 1px solid #2d2d2d;
            border-radius: 12px;
            padding: 16px;
            width: 280px;
            z-index: 1001;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .confidence-meter.minimized {
            width: 60px;
            height: 60px;
            padding: 8px;
            overflow: hidden;
            cursor: pointer;
        }

        .confidence-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .confidence-title {
            font-weight: 600;
            color: #e1e1e1;
            font-size: 14px;
        }

        .confidence-minimize {
            background: none;
            border: none;
            color: #8e8ea0;
            cursor: pointer;
            font-size: 14px;
            padding: 2px;
            display: none;
        }

        .confidence-minimize:hover {
            color: #e1e1e1;
        }

        .confidence-score {
            text-align: center;
            margin-bottom: 16px;
        }

        .confidence-value {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .confidence-value.high {
            color: #10a37f;
        }

        .confidence-value.medium {
            color: #f39c12;
        }

        .confidence-value.low {
            color: #e74c3c;
        }

        .confidence-label {
            font-size: 12px;
            color: #8e8ea0;
        }

        .confidence-bar-container {
            position: relative;
            height: 8px;
            background: #2d2d2d;
            border-radius: 4px;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .confidence-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease, background-color 0.3s ease;
        }

        .confidence-bar.high {
            background: linear-gradient(90deg, #10a37f, #0d8f6b);
        }

        .confidence-bar.medium {
            background: linear-gradient(90deg, #f39c12, #e67e22);
        }

        .confidence-bar.low {
            background: linear-gradient(90deg, #e74c3c, #c0392b);
        }

        .confidence-threshold {
            position: absolute;
            top: -12px;
            height: calc(100% + 24px);
            width: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            margin-left: -14px;
        }

        .confidence-threshold-handle {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            border: 2px solid black;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .confidence-threshold-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: black;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .confidence-threshold:hover .confidence-threshold-handle {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(16, 163, 127, 0.3), 0 2px 6px rgba(0, 0, 0, 0.2);
            border-color: black;
        }

        .confidence-threshold:hover .confidence-threshold-handle::before {
            transform: translate(-50%, -50%) scale(1.1);
            background: black;
        }

        .confidence-threshold.dragging .confidence-threshold-handle {
            transform: scale(1.3);
            box-shadow: 0 6px 16px rgba(16, 163, 127, 0.4), 0 3px 8px rgba(0, 0, 0, 0.25);
            border-color: black;
        }

        .confidence-threshold.dragging .confidence-threshold-handle::before {
            transform: translate(-50%, -50%) scale(1.2);
            background: black;
        }

        .confidence-status {
            font-size: 11px;
            color: #8e8ea0;
            text-align: center;
            margin-top: 8px;
            min-height: 14px;
        }

        .confidence-mini-icon {
            font-size: 20px;
            text-align: center;
            color: #8e8ea0;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .confidence-meter {
                top: 8px;
                right: 8px;
                width: 250px;
            }

            .confidence-meter.minimized {
                width: 50px;
                height: 50px;
            }
        }

        /* Feedback questions styles */
        .feedback-questions {
            background: #171717;
            border: 1px solid #2d2d2d;
            border-radius: 12px;
            padding: 16px;
            margin: 16px 24px;
            max-width: 768px;
            margin-left: auto;
            margin-right: auto;
        }

        .feedback-questions-header {
            color: #e1e1e1;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .feedback-question-item {
            background: #2d2d2d;
            border: 1px solid #4d4d4d;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: #e1e1e1;
            font-size: 14px;
            line-height: 1.4;
        }

        .feedback-question-item:hover {
            background: #3d3d3d;
            border-color: #10a37f;
        }

        .feedback-question-item:last-child {
            margin-bottom: 0;
        }

        @media (max-width: 768px) {
            .feedback-questions {
                margin: 16px;
            }
        }

        /* Schnazzy title styles */
        .schnazzy-title {
            background: linear-gradient(135deg, #10a37f 0%, #1dd1a1 50%, #55efc4 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            font-weight: 700;
            letter-spacing: -0.5px;
            position: relative;
            font-family: 'Inter', 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        }

        .mobile-header .schnazzy-title {
            font-size: 20px;
            padding: 4px 0;
        }

        .chat-header .schnazzy-title {
            font-size: 32px;
            padding: 8px 0;
            margin-bottom: 4px;
        }

        /* Universal metric styles */
        .universal-metric-section {
            margin-top: 20px;
        }

        .confidence-score {
            text-align: center;
            margin-bottom: 16px;
        }

        .confidence-value {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .confidence-label {
            font-size: 12px;
            color: #8e8ea0;
        }

        .confidence-bar-container {
            position: relative;
            height: 8px;
            background: #2d2d2d;
            border-radius: 4px;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .confidence-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease, background-color 0.3s ease;
        }

        .confidence-bar.high {
            background: linear-gradient(90deg, #10a37f, #0d8f6b);
        }

        .confidence-bar.medium {
            background: linear-gradient(90deg, #f39c12, #e67e22);
        }

        .confidence-bar.low {
            background: linear-gradient(90deg, #e74c3c, #c0392b);
        }

        .confidence-status {
            font-size: 11px;
            color: #8e8ea0;
            text-align: center;
            margin-top: 8px;
            min-height: 14px;
        }
    </style>
</head>
<body>
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <button class="new-thread-btn" onclick="startNewChat()">
                <span>+</span>
                New chat
            </button>
        </div>
        <div class="threads-list" id="threadsList">
            <!-- Threads will be loaded here -->
        </div>
    </div>

    <div class="chat-container">
        <div class="mobile-header">
            <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
            <h1 class="schnazzy-title">EntropyAware Answer Engine</h1>
        </div>

        <div class="chat-header">
            <h1 class="schnazzy-title">EntropyAware Answer Engine</h1>
            <div class="current-thread" id="currentThread">
                Select a conversation
            </div>
        </div>

        <div class="chat-messages" id="chatMessages">
            <div class="welcome-message" id="welcomeMessage">
                <h2>Hello. Ask me a challenging question.</h2>
                <p>Set your expected level of response consistency to match the nature of your question.</p>

                <div class="welcome-suggestions" id="welcomeSuggestions">
                    <div class="suggestion-card" onclick="sendSuggestion('Where is the location of 2025 AI Engineer World\'s Fair Agents Hackathon in SF?')">
                        <div class="suggestion-title">Where is the location of 2025 AI Engineer World's Fair Agents Hackathon in SF?</div>
                        <div class="suggestion-desc">Ask about the location of something the assistant not aware of.</div>
                    </div>
                    <div class="suggestion-card" onclick="sendSuggestion('Who was the first president of the United States?')">
                        <div class="suggestion-title">Who was the first president of the United States?</div>
                        <div class="suggestion-desc">Ask about something the assistant is very certain about the answer to.</div>
                    </div>
                    <div class="suggestion-card" onclick="sendSuggestion('How much wood could a wood chuck chuck if a wood chuck could chuck wood?')">
                        <div class="suggestion-title">How much wood could a wood chuck chuck if a wood chuck could chuck wood?</div>
                        <div class="suggestion-desc">Learn about important nature facts.</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="chat-input-container">
            <div class="chat-input-wrapper">
                <form class="chat-input-form" onsubmit="sendMessage(event)">
                    <textarea
                        class="chat-input"
                        id="messageInput"
                        placeholder="Message EntropyAware Answer Engine..."
                        rows="1"
                        required
                    ></textarea>
                    <button type="submit" class="send-btn" id="sendBtn">
                        <span>‚Üë</span>
                    </button>
                </form>
            </div>
        </div>
    </div>

    <!-- Confidence Meter -->
    <div class="confidence-meter" id="confidenceMeter">
        <div class="confidence-header">
            <div class="confidence-title">Confidence</div>
            <button class="confidence-minimize" onclick="toggleConfidenceMeter()">‚àí</button>
        </div>

        <div class="confidence-content" id="confidenceContent">
            <div class="confidence-score">
                <div class="confidence-value" id="confidenceValue">--</div>
                <div class="confidence-label">Response Consistency</div>
            </div>

            <div class="confidence-bar-container">
                <div class="confidence-bar" id="confidenceBar"></div>
                <div class="confidence-threshold" id="confidenceThresholdLine"
                     onmousedown="startDragThreshold(event)"
                     ontouchstart="startDragThreshold(event)">
                    <div class="confidence-threshold-handle"></div>
                </div>
            </div>

            <div class="confidence-status" id="confidenceStatus">
                Waiting for confidence updates...
            </div>

            <!-- Universal Metric (inside the same card) -->
            <div class="universal-metric-section" style="margin-top: 20px;">
                <div class="confidence-score">
                    <div class="confidence-value" id="universalMetricValue">--</div>
                    <div class="confidence-label" id="universalMetricKey">No metric key</div>
                </div>
                <div class="confidence-bar-container">
                    <div class="confidence-bar" id="universalMetricBar"></div>
                </div>
                <div class="confidence-status" id="universalMetricStatus">
                    Waiting for metric updates...
                </div>
            </div>
        </div>

        <div class="confidence-mini-icon" id="confidenceMiniIcon" style="display: none;">
            üìä
        </div>
    </div>

    <script>
        let currentThreadId = null;
        let isStreaming = false;
        let provisionalThreadId = null;

        // Load threads on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadThreads();
            setupTextareaAutoResize();
            // Initialize confidence meter
            updateThresholdLine();
            updateConfidenceStatus('Ready to chat');
            updateConfidenceDisplay(1.0);
        });

        function setupTextareaAutoResize() {
            const textarea = document.getElementById('messageInput');

            textarea.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 200) + 'px';
            });
        }

        // Confidence meter variables
        let currentConfidence = 0;
        let currentThreshold = 0.7;
        let isConfidenceMinimized = false;

        function handleConfidenceUpdate(data) {
            if (data.type === 'confidence_update') {
                updateConfidenceDisplay(data.confidence);
                updateConfidenceStatus(`Updated: ${new Date().toLocaleTimeString()}`);
            }
        }

        function updateConfidenceDisplay(confidence) {
            currentConfidence = confidence;
            const percentage = Math.round(confidence * 100);

            // Update confidence value
            const confidenceValue = document.getElementById('confidenceValue');
            if (confidenceValue) {
                confidenceValue.textContent = `${percentage}%`;
            }

            // Update confidence bar
            const confidenceBar = document.getElementById('confidenceBar');
            if (confidenceBar) {
                confidenceBar.style.width = `${percentage}%`;
            }

            // Update colors based on confidence level
            const level = getConfidenceLevel(confidence);
            if (confidenceValue) {
                confidenceValue.className = `confidence-value ${level}`;
            }
            if (confidenceBar) {
                confidenceBar.className = `confidence-bar ${level}`;
            }

            // Update threshold line position
            updateThresholdLine();
        }

        function getConfidenceLevel(confidence) {
            if (confidence >= currentThreshold) {
                return 'high';
            } else if (confidence >= currentThreshold * 0.7) {
                return 'medium';
            } else {
                return 'low';
            }
        }

        function updateThresholdLine() {
            const thresholdLine = document.getElementById('confidenceThresholdLine');
            if (thresholdLine) {
                thresholdLine.style.left = `${currentThreshold * 100}%`;
            }
        }

        // Threshold dragging functionality
        let isDraggingThreshold = false;
        let thresholdDragStart = 0;

        function startDragThreshold(event) {
            if (isConfidenceMinimized) return;

            isDraggingThreshold = true;
            const thresholdLine = document.getElementById('confidenceThresholdLine');
            thresholdLine.classList.add('dragging');

            // Prevent text selection
            event.preventDefault();

            // Add global event listeners
            document.addEventListener('mousemove', dragThreshold);
            document.addEventListener('mouseup', stopDragThreshold);
            document.addEventListener('touchmove', dragThreshold);
            document.addEventListener('touchend', stopDragThreshold);
        }

        function dragThreshold(event) {
            if (!isDraggingThreshold) return;

            const container = document.querySelector('.confidence-bar-container');
            if (!container) return;

            const rect = container.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);

            // Calculate new threshold position
            const relativeX = clientX - rect.left;
            const newThreshold = Math.max(0, Math.min(1, relativeX / rect.width));

            // Update threshold
            currentThreshold = newThreshold;
            updateThresholdLine();

            // Update colors based on new threshold
            updateConfidenceDisplay(currentConfidence);

            // Update status to show current threshold
            updateConfidenceStatus(`Threshold: ${Math.round(newThreshold * 100)}%`);
        }

        function stopDragThreshold(event) {
            if (!isDraggingThreshold) return;

            isDraggingThreshold = false;
            const thresholdLine = document.getElementById('confidenceThresholdLine');
            thresholdLine.classList.remove('dragging');

            // Remove global event listeners
            document.removeEventListener('mousemove', dragThreshold);
            document.removeEventListener('mouseup', stopDragThreshold);
            document.removeEventListener('touchmove', dragThreshold);
            document.removeEventListener('touchend', stopDragThreshold);

            // Send threshold update to server
            if (currentThreadId) {
                updateThresholdOnServer(currentThreadId, currentThreshold);
            }

            updateConfidenceStatus(`Threshold updated: ${Math.round(currentThreshold * 100)}%`);
        }

        async function updateThresholdOnServer(threadId, threshold) {
            try {
                const response = await fetch(`/api/threads/${threadId}/confidence-threshold`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ threshold: threshold })
                });

                if (!response.ok) {
                    throw new Error('Failed to update threshold');
                }

                console.log('Threshold updated successfully:', threshold);
            } catch (error) {
                console.error('Error updating threshold:', error);
                updateConfidenceStatus('Error updating threshold');
            }
        }

        function updateConfidenceStatus(status) {
            const statusElement = document.getElementById('confidenceStatus');
            if (statusElement) {
                statusElement.textContent = status;
            }
        }

        function handleFeedbackQuestions(questions) {
            if (!questions || questions.length === 0) {
                return;
            }

            // Remove any existing feedback questions
            const existingFeedback = document.querySelector('.feedback-questions');
            if (existingFeedback) {
                existingFeedback.remove();
            }

            // Create feedback questions container
            const feedbackContainer = document.createElement('div');
            feedbackContainer.className = 'feedback-questions';

            const header = document.createElement('div');
            header.className = 'feedback-questions-header';
            header.textContent = 'Follow-up questions:';
            feedbackContainer.appendChild(header);

            // Add each question as a clickable item
            questions.forEach(question => {
                const questionItem = document.createElement('div');
                questionItem.className = 'feedback-question-item';
                questionItem.textContent = question;
                questionItem.onclick = () => sendFeedbackQuestion(question);
                feedbackContainer.appendChild(questionItem);
            });

            // Insert feedback questions after the last message
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(feedbackContainer);
            scrollToBottom();
        }

        async function sendFeedbackQuestion(question) {
            // Remove feedback questions when one is selected
            const feedbackContainer = document.querySelector('.feedback-questions');
            if (feedbackContainer) {
                feedbackContainer.remove();
            }

            // Send the question as a new message
            if (isStreaming) return;

            const messageInput = document.getElementById('messageInput');
            messageInput.value = question;

            // Trigger the send message function
            const event = new Event('submit');
            document.querySelector('.chat-input-form').dispatchEvent(event);
        }

        function toggleConfidenceMeter() {
            const meter = document.getElementById('confidenceMeter');
            const content = document.getElementById('confidenceContent');
            const miniIcon = document.getElementById('confidenceMiniIcon');
            const minimizeBtn = document.querySelector('.confidence-minimize');

            isConfidenceMinimized = !isConfidenceMinimized;

            if (isConfidenceMinimized) {
                meter.classList.add('minimized');
                content.style.display = 'none';
                miniIcon.style.display = 'block';
                minimizeBtn.textContent = '+';
                meter.onclick = toggleConfidenceMeter;
            } else {
                meter.classList.remove('minimized');
                content.style.display = 'block';
                miniIcon.style.display = 'none';
                minimizeBtn.textContent = '‚àí';
                meter.onclick = null;
            }
        }

        async function loadThreads() {
            try {
                const response = await fetch('/api/threads');
                const data = await response.json();

                const threadsList = document.getElementById('threadsList');
                threadsList.innerHTML = '';

                data.threads.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                data.threads.forEach(thread => {
                    const threadElement = document.createElement('button');
                    threadElement.className = 'thread-item';
                    threadElement.onclick = () => selectThread(thread.thread_id);

                    if (thread.thread_id === currentThreadId) {
                        threadElement.classList.add('active');
                    }

                    threadElement.innerHTML = `
                        <div class="thread-content">
                            <div class="thread-title">${thread.title}</div>
                            <div class="thread-meta">${thread.message_count} messages</div>
                        </div>
                        <button class="delete-thread-btn" onclick="deleteThread(event, '${thread.thread_id}')" title="Delete conversation">
                            üóëÔ∏è
                        </button>
                    `;

                    threadsList.appendChild(threadElement);
                });

                // Only auto-select if we're reloading threads for an existing conversation
                // Otherwise, show the no messages screen by default
                if (currentThreadId && data.threads.find(t => t.thread_id === currentThreadId)) {
                    // Maintain current selection if it still exists
                    await selectThread(currentThreadId);
                } else if (data.threads.length === 0) {
                    // Show no messages screen if no threads exist
                    showNoMessagesScreen();
                } else {
                    // Show no messages screen by default when app loads
                    showNoMessagesScreen();
                }
            } catch (error) {
                console.error('Error loading threads:', error);
                showError('Failed to load conversations');
            }
        }

        function showNoMessagesScreen() {
            currentThreadId = null;
            provisionalThreadId = null;

            const chatMessages = document.getElementById('chatMessages');
            const welcomeMessage = document.getElementById('welcomeMessage');

            // Clear any existing messages
            const existingMessages = chatMessages.querySelectorAll('.message-wrapper');
            existingMessages.forEach(msg => msg.remove());

            // Clear any existing feedback questions
            const existingFeedback = document.querySelector('.feedback-questions');
            if (existingFeedback) {
                existingFeedback.remove();
            }

            // Show welcome message
            chatMessages.classList.remove('has-messages');
            welcomeMessage.style.display = 'block';

            document.getElementById('currentThread').textContent = 'Start a new conversation';
        }

        function startNewChat() {
            // Show no messages screen without creating a thread yet
            showNoMessagesScreen();

            // Close sidebar on mobile
            if (window.innerWidth <= 768) {
                toggleSidebar();
            }
        }

        async function selectThread(threadId) {
            currentThreadId = threadId;
            provisionalThreadId = null;

            // Update active state in sidebar
            document.querySelectorAll('.thread-item').forEach(item => {
                item.classList.remove('active');
            });
            event?.target.closest('.thread-item')?.classList.add('active');

            // Update current thread display
            const threadInfo = await getThreadInfo(threadId);
            document.getElementById('currentThread').textContent = `Thread: ${threadInfo.title}`;

            // Load thread history
            await loadThreadHistory(threadId);

            // Fetch and update confidence and universal metric for this thread
            await Promise.all([
                loadThreadConfidence(threadId),
                loadThreadUniversalMetric(threadId)
            ]);

            // Close sidebar on mobile
            if (window.innerWidth <= 768) {
                toggleSidebar();
            }
        }

        async function getThreadInfo(threadId) {
            const response = await fetch('/api/threads');
            const data = await response.json();
            return data.threads.find(t => t.thread_id === threadId);
        }

        async function loadThreadConfidence(threadId) {
            try {
                const response = await fetch(`/api/threads/${threadId}/confidence`);
                const data = await response.json();

                // Update the confidence display with the thread's current confidence
                updateConfidenceDisplay(data.confidence);
                updateConfidenceStatus(`Thread confidence loaded: ${Math.round(data.confidence * 100)}%`);
            } catch (error) {
                console.error('Error loading thread confidence:', error);
                // Don't show error to user, just log it and use default
                updateConfidenceDisplay(1.0);
                updateConfidenceStatus('Unable to load confidence - using default');
            }
        }

        async function deleteThread(event, threadId) {
            event.stopPropagation();

            if (!confirm('Are you sure you want to delete this conversation?')) {
                return;
            }

            try {
                await fetch(`/api/threads/${threadId}`, {
                    method: 'DELETE'
                });

                // If we're deleting the current thread, show no messages screen
                if (threadId === currentThreadId) {
                    showNoMessagesScreen();
                }

                // Reload threads
                await loadThreads();
            } catch (error) {
                console.error('Error deleting thread:', error);
                showError('Failed to delete conversation');
            }
        }

        async function ensureThreadExists() {
            if (currentThreadId) {
                return currentThreadId;
            }

            if (provisionalThreadId) {
                return provisionalThreadId;
            }

            // Create a new provisional thread
            try {
                const response = await fetch('/api/threads', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                });

                const data = await response.json();
                provisionalThreadId = data.thread_id;
                return provisionalThreadId;
            } catch (error) {
                console.error('Error creating provisional thread:', error);
                throw error;
            }
        }

        async function sendSuggestion(message) {
            if (isStreaming) return;

            const messageInput = document.getElementById('messageInput');
            messageInput.value = message;

            // Trigger the send message function
            const event = new Event('submit');
            document.querySelector('.chat-input-form').dispatchEvent(event);
        }

        async function loadThreadHistory(threadId) {
            try {
                const response = await fetch(`/api/threads/${threadId}/history`);
                const data = await response.json();

                const chatMessages = document.getElementById('chatMessages');
                const welcomeMessage = document.getElementById('welcomeMessage');

                // Clear existing messages except welcome
                const existingMessages = chatMessages.querySelectorAll('.message-wrapper');
                existingMessages.forEach(msg => msg.remove());

                // Clear any existing feedback questions
                const existingFeedback = document.querySelector('.feedback-questions');
                if (existingFeedback) {
                    existingFeedback.remove();
                }

                if (data.messages.length === 0) {
                    chatMessages.classList.remove('has-messages');
                    welcomeMessage.style.display = 'block';
                } else {
                    chatMessages.classList.add('has-messages');
                    welcomeMessage.style.display = 'none';

                    data.messages.forEach(msg => {
                        addMessage(msg.content, msg.type === 'human' ? 'user' : 'assistant');
                    });
                }

                scrollToBottom();
            } catch (error) {
                console.error('Error loading thread history:', error);
                showError('Failed to load conversation history');
            }
        }

        async function sendMessage(event) {
            event.preventDefault();

            if (isStreaming) {
                return;
            }

            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (!message) return;

            // Clear any existing feedback questions when sending a new message
            const existingFeedback = document.querySelector('.feedback-questions');
            if (existingFeedback) {
                existingFeedback.remove();
            }

            // Ensure we have a thread (create provisional if needed)
            const threadId = await ensureThreadExists();

            // Add user message to chat
            addMessage(message, 'user');
            messageInput.value = '';
            messageInput.style.height = 'auto';

            // Disable input and show loading
            setStreamingState(true);

            try {
                // Create assistant message element for streaming
                const assistantMessage = addMessage('', 'assistant', true);

                // Start streaming
                const response = await fetch('/api/chat/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        thread_id: threadId
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));

                                if (data.type === 'token') {
                                    assistantMessage.textContent += data.content;
                                    scrollToBottom();
                                } else if (data.type === 'confidence_update') {
                                    if (data.thread_id === currentThreadId || data.thread_id === threadId) {
                                        handleConfidenceUpdate(data);
                                    }
                                } else if (data.type === 'universal_metric_update') {
                                    if (data.thread_id === currentThreadId || data.thread_id === threadId) {
                                        updateUniversalMetricDisplay(data);
                                        updateUniversalMetricStatus(`Updated: ${new Date().toLocaleTimeString()}`);
                                    }
                                } else if (data.type === 'feedback_questions') {
                                    // Handle feedback questions
                                    if (data.thread_id === currentThreadId || data.thread_id === threadId) {
                                        handleFeedbackQuestions(data.feedback_questions);
                                    }
                                } else if (data.type === 'complete') {
                                    assistantMessage.classList.remove('streaming');

                                    // Convert provisional thread to real thread
                                    if (provisionalThreadId && !currentThreadId) {
                                        currentThreadId = provisionalThreadId;
                                        provisionalThreadId = null;
                                        document.getElementById('currentThread').textContent = `Thread: ${currentThreadId}`;
                                    }

                                    // Always reload threads to update message count in sidebar
                                    await loadThreads();

                                    // Update confidence status to indicate streaming is complete
                                    if (currentThreadId) {
                                        updateConfidenceStatus('Response complete - monitoring for updates');
                                    }

                                    // Also load universal metric when complete
                                    if (currentThreadId) {
                                        await loadThreadUniversalMetric(currentThreadId);
                                    }
                                } else if (data.type === 'error') {
                                    showError(`Error: ${data.message}`);
                                    assistantMessage.textContent = 'Sorry, I encountered an error processing your request.';
                                    assistantMessage.classList.remove('streaming');
                                }
                            } catch (e) {
                                // Ignore JSON parse errors for incomplete chunks
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('Error sending message:', error);
                showError('Failed to send message');
            } finally {
                setStreamingState(false);
            }
        }

        function addMessage(content, type, streaming = false) {
            const chatMessages = document.getElementById('chatMessages');
            const welcomeMessage = document.getElementById('welcomeMessage');

            // Hide welcome message when first message is added
            if (!chatMessages.classList.contains('has-messages')) {
                chatMessages.classList.add('has-messages');
                welcomeMessage.style.display = 'none';
            }

            const messageWrapper = document.createElement('div');
            messageWrapper.className = `message-wrapper ${type}`;

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            const avatar = document.createElement('div');
            avatar.className = `message-avatar ${type}`;
            avatar.textContent = type === 'user' ? 'U' : 'AI';

            const messageText = document.createElement('div');
            messageText.className = 'message-text';
            if (streaming) {
                messageText.classList.add('streaming');
            }
            messageText.textContent = content;

            messageContent.appendChild(avatar);
            messageContent.appendChild(messageText);
            messageWrapper.appendChild(messageContent);
            chatMessages.appendChild(messageWrapper);

            scrollToBottom();
            return messageText;
        }

        function setStreamingState(streaming) {
            isStreaming = streaming;
            const sendBtn = document.getElementById('sendBtn');
            const messageInput = document.getElementById('messageInput');

            sendBtn.disabled = streaming;
            messageInput.disabled = streaming;
        }

        function scrollToBottom() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showError(message) {
            const chatMessages = document.getElementById('chatMessages');
            const errorElement = document.createElement('div');
            errorElement.className = 'error';
            errorElement.textContent = message;
            chatMessages.appendChild(errorElement);
            scrollToBottom();

            // Remove error after 5 seconds
            setTimeout(() => {
                errorElement.remove();
            }, 5000);
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');

            sidebar.classList.toggle('show');
            overlay.classList.toggle('show');
        }

        // Handle Enter key in textarea
        document.getElementById('messageInput').addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(event);
            }
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const menuToggle = document.querySelector('.menu-toggle');

            if (window.innerWidth <= 768 &&
                sidebar.classList.contains('show') &&
                !sidebar.contains(event.target) &&
                !menuToggle.contains(event.target)) {
                toggleSidebar();
            }
        });

        // Universal metric variables
        let isUniversalMetricMinimized = false;

        function toggleUniversalMetric() {
            const meter = document.getElementById('confidenceMeter');
            const content = document.getElementById('confidenceContent');
            const miniIcon = document.getElementById('confidenceMiniIcon');
            const minimizeBtn = meter.querySelector('.confidence-minimize');

            isUniversalMetricMinimized = !isUniversalMetricMinimized;

            if (isUniversalMetricMinimized) {
                meter.classList.add('minimized');
                content.style.display = 'none';
                miniIcon.style.display = 'block';
                minimizeBtn.textContent = '+';
                meter.onclick = toggleUniversalMetric;
            } else {
                meter.classList.remove('minimized');
                content.style.display = 'block';
                miniIcon.style.display = 'none';
                minimizeBtn.textContent = '‚àí';
                meter.onclick = null;
            }
        }

        async function loadThreadUniversalMetric(threadId) {
            try {
                const response = await fetch(`/api/threads/${threadId}/uiversal_metric_key`);
                const data = await response.json();

                // Update the universal metric display
                updateUniversalMetricDisplay(data);
                updateUniversalMetricStatus(`Metric updated: ${new Date().toLocaleTimeString()}`);
            } catch (error) {
                console.error('Error loading universal metric:', error);
                updateUniversalMetricDisplay({});
                updateUniversalMetricStatus('Unable to load metric - using default');
            }
        }

        function updateUniversalMetricDisplay(data) {
            const metricValue = document.getElementById('universalMetricValue');
            const metricBar = document.getElementById('universalMetricBar');
            const metricKey = document.getElementById('universalMetricKey');
            
            if (data.metric_score !== undefined) {
                const percentage = Math.round(data.metric_score * 100);
                metricValue.textContent = `${percentage}%`;
                metricBar.style.width = `${percentage}%`;
                
                // Update metric key
                metricKey.textContent = data.metric_key || 'Unknown metric';
                
                // Update colors based on metric score
                const level = getConfidenceLevel(data.metric_score);
                metricValue.className = `confidence-value ${level}`;
                metricBar.className = `confidence-bar ${level}`;
            } else {
                metricValue.textContent = '--';
                metricBar.style.width = '0%';
                metricKey.textContent = 'No metric key';
                metricValue.className = 'confidence-value';
                metricBar.className = 'confidence-bar';
            }
        }

        function updateUniversalMetricStatus(status) {
            const statusElement = document.getElementById('universalMetricStatus');
            if (statusElement) {
                statusElement.textContent = status;
            }
        }
    </script>
</body>
</html>